"use strict";(self.webpackChunkcode_harbor_hub=self.webpackChunkcode_harbor_hub||[]).push([[9376],{204:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>m,toc:()=>u});var n=t(17624),r=t(4552),i=t(86212),o=t(22440),l=t(62928);const s={id:"space-complexity",title:"Space Complexity",sidebar_label:"Space Complexity",sidebar_position:2,description:"Space complexity is a measure of the amount of working storage an algorithm needs. It is a measure of the amount of memory space an algorithm needs to solve a problem as a function of the size of the input to the problem. It is the amount of memory space required by the algorithm to execute in its life cycle.",tags:["Space Complexity","Big O Notation","Memory","Algorithm","Complexity Analysis","Data Structure","DSA","JavaScript","Java","Python","C","C++","Space Complexity Example","Space Complexity Calculation","Space Complexity Analysis","Space Complexity Explanation","Space Complexity Conclusion","Space Complexity Importance","Space Complexity Formula","Space Complexity Constant Space","Space Complexity Auxiliary Space","Space Complexity Example","Space Complexity Program","Space Complexity Code"]},c=void 0,m={id:"basic-concepts/space-complexity",title:"Space Complexity",description:"Space complexity is a measure of the amount of working storage an algorithm needs. It is a measure of the amount of memory space an algorithm needs to solve a problem as a function of the size of the input to the problem. It is the amount of memory space required by the algorithm to execute in its life cycle.",source:"@site/dsa/basic-concepts/space-complexity.md",sourceDirName:"basic-concepts",slug:"/basic-concepts/space-complexity",permalink:"/code-harbor-hub/dsa/basic-concepts/space-complexity",draft:!1,unlisted:!1,tags:[{label:"Space Complexity",permalink:"/code-harbor-hub/dsa/tags/space-complexity"},{label:"Big O Notation",permalink:"/code-harbor-hub/dsa/tags/big-o-notation"},{label:"Memory",permalink:"/code-harbor-hub/dsa/tags/memory"},{label:"Algorithm",permalink:"/code-harbor-hub/dsa/tags/algorithm"},{label:"Complexity Analysis",permalink:"/code-harbor-hub/dsa/tags/complexity-analysis"},{label:"Data Structure",permalink:"/code-harbor-hub/dsa/tags/data-structure"},{label:"DSA",permalink:"/code-harbor-hub/dsa/tags/dsa"},{label:"JavaScript",permalink:"/code-harbor-hub/dsa/tags/java-script"},{label:"Java",permalink:"/code-harbor-hub/dsa/tags/java"},{label:"Python",permalink:"/code-harbor-hub/dsa/tags/python"},{label:"C",permalink:"/code-harbor-hub/dsa/tags/c"},{label:"Space Complexity Example",permalink:"/code-harbor-hub/dsa/tags/space-complexity-example"},{label:"Space Complexity Calculation",permalink:"/code-harbor-hub/dsa/tags/space-complexity-calculation"},{label:"Space Complexity Analysis",permalink:"/code-harbor-hub/dsa/tags/space-complexity-analysis"},{label:"Space Complexity Explanation",permalink:"/code-harbor-hub/dsa/tags/space-complexity-explanation"},{label:"Space Complexity Conclusion",permalink:"/code-harbor-hub/dsa/tags/space-complexity-conclusion"},{label:"Space Complexity Importance",permalink:"/code-harbor-hub/dsa/tags/space-complexity-importance"},{label:"Space Complexity Formula",permalink:"/code-harbor-hub/dsa/tags/space-complexity-formula"},{label:"Space Complexity Constant Space",permalink:"/code-harbor-hub/dsa/tags/space-complexity-constant-space"},{label:"Space Complexity Auxiliary Space",permalink:"/code-harbor-hub/dsa/tags/space-complexity-auxiliary-space"},{label:"Space Complexity Program",permalink:"/code-harbor-hub/dsa/tags/space-complexity-program"},{label:"Space Complexity Code",permalink:"/code-harbor-hub/dsa/tags/space-complexity-code"}],version:"current",lastUpdatedBy:"ajay-dhangar",lastUpdatedAt:1710086229,formattedLastUpdatedAt:"Mar 10, 2024",sidebarPosition:2,frontMatter:{id:"space-complexity",title:"Space Complexity",sidebar_label:"Space Complexity",sidebar_position:2,description:"Space complexity is a measure of the amount of working storage an algorithm needs. It is a measure of the amount of memory space an algorithm needs to solve a problem as a function of the size of the input to the problem. It is the amount of memory space required by the algorithm to execute in its life cycle.",tags:["Space Complexity","Big O Notation","Memory","Algorithm","Complexity Analysis","Data Structure","DSA","JavaScript","Java","Python","C","C++","Space Complexity Example","Space Complexity Calculation","Space Complexity Analysis","Space Complexity Explanation","Space Complexity Conclusion","Space Complexity Importance","Space Complexity Formula","Space Complexity Constant Space","Space Complexity Auxiliary Space","Space Complexity Example","Space Complexity Program","Space Complexity Code"]},sidebar:"codeharborhub",previous:{title:"Time Complexity",permalink:"/code-harbor-hub/dsa/basic-concepts/time-complexity"}},p={},u=[{value:"Why is Space Complexity important?",id:"why-is-space-complexity-important",level:2},{value:"How to calculate Space Complexity?",id:"how-to-calculate-space-complexity",level:2},{value:"Example",id:"example",level:2},{value:"Example of Space Complexity",id:"example-of-space-complexity",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const a={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.p,{children:"Space complexity is a measure of the amount of working storage an algorithm needs. It is a measure of the amount of memory space an algorithm needs to solve a problem as a function of the size of the input to the problem. It is the amount of memory space required by the algorithm to execute in its life cycle."}),"\n",(0,n.jsx)(a.h2,{id:"why-is-space-complexity-important",children:"Why is Space Complexity important?"}),"\n",(0,n.jsx)(a.p,{children:"Space complexity is important because the memory that is allocated to the program is limited. If the program uses more memory than the available memory, the program will crash. Therefore, it is important to know the space complexity of the algorithm."}),"\n",(0,n.jsx)(a.h2,{id:"how-to-calculate-space-complexity",children:"How to calculate Space Complexity?"}),"\n",(0,n.jsx)(a.p,{children:"Space complexity is calculated by counting the amount of memory space used by the algorithm. It is calculated by counting the amount of memory space used by the algorithm as a function of the size of the input to the problem."}),"\n",(0,n.jsx)(a.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",metastring:'title="Space Complexity"',children:"function sumOfN(n) {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n"})}),"\n",(0,n.jsx)(a.p,{children:"In the above example, the space complexity of the algorithm is O(1) because the algorithm uses a constant amount of memory space."}),"\n",(0,n.jsx)(a.h2,{id:"example-of-space-complexity",children:"Example of Space Complexity"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsx)(a.li,{children:"Write a program to fine maximum and minimum element in an array."}),"\n"]}),"\n",(0,n.jsxs)(i.c,{children:[(0,n.jsxs)(o.c,{value:"js",label:"JavaScipt",default:!0,children:[(0,n.jsx)(l.c,{name:"@Ajay-Dhangar"}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",metastring:"{6,9,12}",children:"function findMaxMin(arr) {\n  let max = arr[0];\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return { max, min };\n}\n\nconst arr = [2, 5, 1, 20, 10];\nconsole.log(findMaxMin(arr)); // { max: 20, min: 1 }\n"})})]}),(0,n.jsxs)(o.c,{value:"java",label:"Java",children:[(0,n.jsx)(l.c,{name:"@Ajay-Dhangar"}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-java",children:'public class Main {\n    public static void main(String[] args) {\n       int[] arr = {2, 5, 1, 20, 10};\n       System.out.println(findMaxMin(arr)); // { max: 20, min: 1 }\n    }\n\n    public static Map<String, Integer> findMaxMin(int[] arr) {\n        int max = arr[0];\n        int min = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n            if (arr[i] < min) {\n               min = arr[i];\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        result.put("max", max);\n        result.put("min", min);\n        return result;\n    }\n}\n'})})]}),(0,n.jsxs)(o.c,{value:"python",label:"Python",children:[(0,n.jsx)(l.c,{name:"@Ajay-Dhangar"}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:'def find_max_min(arr):\n    max = arr[0]\n    min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > max:\n            max = arr[i]\n        if arr[i] < min:\n            min = arr[i]\n    return {"max": max, "min": min}\n\narr = [2, 5, 1, 20, 10]\nprint(find_max_min(arr)) # { max: 20, min: 1 }\n'})})]}),(0,n.jsxs)(o.c,{value:"c",label:"C",children:[(0,n.jsx)(l.c,{name:"@Ajay-Dhangar"}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-c",children:'#include <stdio.h>\n\nstruct MaxMin {\n    int max;\n    int min;\n};\n\nstruct MaxMin findMaxMin(int arr[], int n) {\n    struct MaxMin result;\n    result.max = arr[0];\n    result.min = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > result.max) {\n            result.max = arr[i];\n        }\n        if (arr[i] < result.min) {\n            result.min = arr[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    int arr[] = {2, 5, 1, 20, 10};\n    struct MaxMin result = findMaxMin(arr, 5);\n    printf("{ max: %d, min: %d }\\n", result.max, result.min); // { max: 20, min: 1 }\n    return 0;\n}\n'})})]}),(0,n.jsxs)(o.c,{value:"cpp",label:"C++",children:[(0,n.jsx)(l.c,{name:"@Ajay-Dhangar"}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-cpp",children:'#include <iostream>\n#include <map>\n#include <vector>\n\nstd::map<std::string, int> findMaxMin(std::vector<int> arr) {\n    int max = arr[0];\n    int min = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    std::map<std::string, int> result;\n    result["max"] = max;\n    result["min"] = min;\n    return result;\n}\n\nint main() {\n    std::vector<int> arr = {2, 5, 1, 20, 10};\n    std::map<std::string, int> result = findMaxMin(arr);\n    std::cout << "{ max: " << result["max"] << ", min: " << result["min"] << " }\\n"; // { max: 20, min: 1 }\n    return 0;\n}\n'})})]})]}),"\n",(0,n.jsx)(a.p,{children:"In the above example, the space complexity of the algorithm is O(1) because the algorithm uses a constant amount of memory space."}),"\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.strong,{children:"Explanation:"})," In the above example, we are finding the maximum and minimum element in an array. We are using two variables ",(0,n.jsx)(a.code,{children:"max"})," and ",(0,n.jsx)(a.code,{children:"min"})," to store the maximum and minimum element in the array. We are using a constant amount of memory space to store the maximum and minimum element in the array. Therefore, the space complexity of the algorithm is O(1)."]}),"\n",(0,n.jsxs)(a.admonition,{title:"Complexity Analysis",type:"info",children:[(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Farmula to calculate Space Complexity"})}),(0,n.jsx)(a.p,{children:"Space Complexity = Constant Space + Auxiliary Space"}),(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.strong,{children:"Constant Space:"})," The amount of space used by the algorithm that is not dependent on the size of the input to the problem. It is a constant amount of memory space used by the algorithm."]}),(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.strong,{children:"Auxiliary Space:"})," The amount of space used by the algorithm that is dependent on the size of the input to the problem. It is a variable amount of memory space used by the algorithm."]}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-plaintext",metastring:'title="Space Complexity"',children:"Space Complexity = O(1) + O(n) = O(n)\n"})}),(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"For Example:"})}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",metastring:'title="Space Complexity"',children:"function sumOfN(n) {\n  let sum = 0; // Constant Space (O(1))\n  for (let i = 1; i <= n; i++) {\n    sum += i; // Auxiliary Space (O(n))\n  }\n  return sum;\n}\n"})}),(0,n.jsxs)(a.p,{children:["In the above example, the space complexity of the algorithm is ",(0,n.jsx)(a.code,{children:"O(1) + O(n) = O(n)"}),"."]})]}),"\n",(0,n.jsx)(a.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(a.p,{children:"Space complexity is a measure of the amount of working storage an algorithm needs. It is a measure of the amount of memory space an algorithm needs to solve a problem as a function of the size of the input to the problem. It is the amount of memory space required by the algorithm to execute in its life cycle."})]})}function d(e={}){const{wrapper:a}={...(0,r.M)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},22440:(e,a,t)=>{t.d(a,{c:()=>o});t(11504);var n=t(65456);const r={tabItem:"tabItem_Ymn6"};var i=t(17624);function o(e){let{children:a,hidden:t,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,n.c)(r.tabItem,o),hidden:t,children:a})}},86212:(e,a,t)=>{t.d(a,{c:()=>v});var n=t(11504),r=t(65456),i=t(77288),o=t(55592),l=t(83472),s=t(95068),c=t(30604),m=t(46432);function p(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:a,children:t}=e;return(0,n.useMemo)((()=>{const e=a??function(e){return p(e).map((e=>{let{props:{value:a,label:t,attributes:n,default:r}}=e;return{value:a,label:t,attributes:n,default:r}}))}(t);return function(e){const a=(0,c.w)(e,((e,a)=>e.value===a.value));if(a.length>0)throw new Error(`Docusaurus error: Duplicate values "${a.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[a,t])}function h(e){let{value:a,tabValues:t}=e;return t.some((e=>e.value===a))}function d(e){let{queryString:a=!1,groupId:t}=e;const r=(0,o.Uz)(),i=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:a,groupId:t});return[(0,s._M)(i),(0,n.useCallback)((e=>{if(!i)return;const a=new URLSearchParams(r.location.search);a.set(i,e),r.replace({...r.location,search:a.toString()})}),[i,r])]}function x(e){const{defaultValue:a,queryString:t=!1,groupId:r}=e,i=u(e),[o,s]=(0,n.useState)((()=>function(e){let{defaultValue:a,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!h({value:a,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${a}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return a}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:a,tabValues:i}))),[c,p]=d({queryString:t,groupId:r}),[x,y]=function(e){let{groupId:a}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(a),[r,i]=(0,m.IN)(t);return[r,(0,n.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),b=(()=>{const e=c??x;return h({value:e,tabValues:i})?e:null})();(0,l.c)((()=>{b&&s(b)}),[b]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),p(e),y(e)}),[p,y,i]),tabValues:i}}var y=t(89788);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(17624);function g(e){let{className:a,block:t,selectedValue:n,selectValue:o,tabValues:l}=e;const s=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.MV)(),m=e=>{const a=e.currentTarget,t=s.indexOf(a),r=l[t].value;r!==n&&(c(a),o(r))},p=e=>{let a=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;a=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;a=s[t]??s[s.length-1];break}}a?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.c)("tabs",{"tabs--block":t},a),children:l.map((e=>{let{value:a,label:t,attributes:i}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:n===a?0:-1,"aria-selected":n===a,ref:e=>s.push(e),onKeyDown:p,onClick:m,...i,className:(0,r.c)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":n===a}),children:t??a},a)}))})}function S(e){let{lazy:a,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){const e=i.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,a)=>(0,n.cloneElement)(e,{key:a,hidden:e.props.value!==r})))})}function C(e){const a=x(e);return(0,f.jsxs)("div",{className:(0,r.c)("tabs-container",b.tabList),children:[(0,f.jsx)(g,{...e,...a}),(0,f.jsx)(S,{...e,...a})]})}function v(e){const a=(0,y.c)();return(0,f.jsx)(C,{...e,children:p(e.children)},String(a))}},62928:(e,a,t)=>{t.d(a,{c:()=>r});t(11504);var n=t(17624);function r(e){let{name:a}=e;return(0,n.jsx)("div",{className:"solution-author-wrapper",children:(0,n.jsxs)("span",{children:["Written by ",a]})})}},4552:(e,a,t)=>{t.d(a,{I:()=>l,M:()=>o});var n=t(11504);const r={},i=n.createContext(r);function o(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);